
import (
	"../umbox/filepath/filepath.um"
	"../umbox/strings/strings.um"
	"../umbox/os/os.um"
	"std.um"

	"newbuild.um"
	"common.um"
)

type Dep* = struct {
	full: str
	url: str
	ref: str
	name: str
	canonical: str
	srcPath: str
	dstPath: str
	buildOnly: bool
}

fn git_init()
fn git_strerror(): str
fn git_updaterepo(dep, ref, dir: str): int
fn fetchFor(deps: []Dep): std::Err

var fetched, built: map[str]bool

fn link(target, link: str): std::Err {
	printf("link %s -> %s\n", link, target)

	os::mkdirp(filepath::dir(link))
	err := os::link(target, link)
	if err.code != 0 && os::getPlatform() == os::Platform.windows {
		std::system("mklink /j " + target + " " + link)
		return {}
	}

	if err.code == 17 {
		return {}
	}
	return err
}

fn getDeps(path: str): ([]Dep, std::Err) {
	meta, err := common::getMeta(filepath::join(path, "box.json"))
	if err.code != 0 {
		return {}, common::error(.boxJsonError, err.msg)
	}

	deps := []Dep{}
	src := []any{}

	if a := ^[]any(meta.others["deps"]); a != null {
		src = a^
	} else {
		printf("warning: invalid or missing deps field\n")
	}

	buildCut := len(src)

	if a := ^[]any(meta.others["bdeps"]); a != null {
		src = append(src, a^)
	}

	for i,a in src {
		if ^str(a) == null {
			return {}, common::error(.boxJsonError, sprintf("dependency '%v' is not a string", a))
		}

		d := Dep{}
		d.full = str(a)
		split := strings::split(d.full, "@")
		if len(split) < 2 {
			return {}, common::error(.boxJsonError, sprintf("invalid dependency '%s'", d.full))
		}
		d.url = strings::join(slice(split, 0, len(split) - 1), "@")
		d.ref = split[len(split) - 1]
		d.canonical = strings::replace(d.full, "/", "_")
		d.name = filepath::file(d.url)
		d.srcPath = filepath::join("umbox", "gitsrc", d.canonical)
		d.dstPath = filepath::join("umbox", "gitdst", d.canonical)
		d.buildOnly = i >= buildCut

		deps = append(deps, d)
	}
	
	return deps, {}
}

fn (d: ^Dep) fetch(): std::Err {
	if fetched[d.full] {
		return {}
	}

	os::mkdirp(d.srcPath)
	printf("Fetch %s\n", d.full)
	if ec := git_updaterepo(d.url, d.ref, d.srcPath); ec != 0 {
		return common::error(.gitError, git_strerror())
	}

	fetched[d.full] = true

	deps, err := getDeps(d.srcPath)
	if err.code != 0 {
		return err
	}

	return fetchFor(deps)
}

fn fetchFor(deps: []Dep): std::Err {
	os::mkdirp("umbox")
	for i,d in deps {
		if err := d.fetch(); err.code != 0 {
			return err
		}
	}

	return {}
}

fn (d: ^Dep) build(): std::Err {
	if built[d.full] {
		return {}
	}

	cwd, err := os::getCwd()
	if err.code != 0 {
		return err
	}

	err = os::chdir(d.srcPath)
	if err.code != 0 {
		return err
	}

	out := newbuild::DirOutput{ filepath::join(cwd, d.dstPath) }
	err = newbuild::run(out, {})
	if err.code != 0 {
		return err
	}

	err = os::chdir(cwd)
	if err.code != 0 {
		return err
	}

	built[d.full] = true

	return {}
}

fn buildFor(deps: []Dep): std::Err {
	for i,d in deps {
		child_deps, err := getDeps(d.srcPath)
		if err.code != 0 {
			return err
		}

		if err := buildFor(child_deps); err.code != 0 {
			return err
		}

		for j,cd in child_deps {
			if !cd.buildOnly {
				continue
			}

			err := link(
				filepath::join("..", "..", "gitdst", cd.canonical),
				filepath::join(d.srcPath, "umbox", cd.name))
			if err.code != 0 {
				return err
			}
		}

		if err := d.build(); err.code != 0 {
			return err
		}

		for j,cd in child_deps {
			if cd.buildOnly {
				continue
			}

			err := link(
				filepath::join("..", "..", cd.canonical),
				filepath::join(d.dstPath, "umbox", cd.name))
			if err.code != 0 {
				return err
			}
		}
	}

	return {}
}

fn run*(baseDir: str = ""): std::Err {
	git_init()

	deps, err := getDeps("")
	if err.code != 0 {
		return err
	}

	err = fetchFor(deps)
	if err.code != 0 {
		return err
	}

	err = buildFor(deps)
	if err.code != 0 {
		return err
	}
	
	for i,d in deps {
		err = link(
			filepath::join("gitdst", d.canonical),
			filepath::join(baseDir, "umbox", d.name))
		if err.code != 0 {
			return err
		}
	}
	
	return {}
}
