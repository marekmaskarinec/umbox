
import (
	"std.um"
	"../umbox/os/os.um"
	"../umbox/json/json.um"
	"../umbox/io/io.um"
	"../umbox/http/http.um"
	"../umbox/jsonenc/jsonenc.um"
)

var url*: str = "https://umbox.tophat2d.dev/"

type Meta* = struct {
	name: str
	version: str
	author: str
	license: str
	description: str
	readme: str
	link: str
	dependencies: []str
	include: []str
	run: str
	runPosix: str
	runWindows: str
	preBuild: str
	postBuild: str
}

fn (m: ^Meta) toJSON*(): str {
	enc := jsonenc.mk()

	enc.startObject()
		enc.putKey("name"); enc.putVal(m.name)
		enc.putKey("version"); enc.putVal(m.version)
		enc.putKey("author"); enc.putVal(m.author)
		enc.putKey("license"); enc.putVal(m.license)
		enc.putKey("description"); enc.putVal(m.description)
		enc.putKey("readme"); enc.putVal(m.readme)
		enc.putKey("link"); enc.putVal(m.link)
		enc.putKey("dependencies"); enc.startArray()
			for i,v in m.dependencies {
				enc.putVal(v)
			}
		enc.endArray()
			
		enc.putKey("include"); enc.startArray()
			for i,v in m.include {
				enc.putVal(v)
			}
		enc.endArray()
			
		if len(m.run) > 0 {
			enc.putKey("run"); enc.putVal(m.run)
		}

		if len(m.runPosix) > 0 {
			enc.putKey("run_posix"); enc.putVal(m.runPosix)
		}

		if len(m.runWindows) > 0 {
			enc.putKey("run_windows"); enc.putVal(m.runWindows)
		}

		if len(m.preBuild) > 0 {
			enc.putKey("pre_build"); enc.putVal(m.preBuild)
		}

		if len(m.postBuild) > 0 {
			enc.putKey("post_build"); enc.putVal(m.postBuild)
		}
	enc.endObject()

	return enc.toStr()
}

fn getMeta*(path: str): (bool, Meta) {
	if !os.isfile(path) {
		return false, {}
	}
	
	f := std.fopen(path, "r")
	r := ^map[str]any(json.parse(str([]char(io.mkFile(f).read()))))
	std.fclose(f)
	if r == null {
		return false, {}
	}
	   
	m := Meta{}

	if ^str(r["name"]) != null {
		m.name = str(r["name"])
	} else {
		fprintf(std.stderr(), "%s: missing key 'name'\n", path)
		return false, {}
	}
	
	if ^str(r["version"]) != null {
		m.version = str(r["version"])
	} else {
		fprintf(std.stderr(), "%s: missing key 'version'\n", path)
		return false, {}
	}
	
	if ^str(r["author"]) != null {
		m.author = str(r["author"])
	} else {
		fprintf(std.stderr(), "%s: missing key 'author'\n", path)
		return false, {}
	}

	if ^str(r["license"]) != null {
		m.license = str(r["license"])
	} else {
		fprintf(std.stderr(), "%s: missing key 'license'\n", path)
		return false, {}
	}

	if ^str(r["description"]) != null {
		m.description = str(r["description"])
	} else {
		fprintf(std.stderr(), "%s: missing key 'description'\n", path)
		return false, {}
	}

	if ^str(r["readme"]) != null {
		m.readme = str(r["readme"])
	} else {
		fprintf(std.stderr(), "%s: missing key 'readme'\n", path)
		return false, {}
	}

	if ^str(r["link"]) != null {
		m.link = str(r["link"])
	} else {
		fprintf(std.stderr(), "%s: missing key 'link'\n", path)
		return false, {}
	}

	if ^[]any(r["dependencies"]) != null {
		m.dependencies = make([]str, len([]any(r["dependencies"])))
		for i, v in []any(r["dependencies"]) {
			m.dependencies[i] = str(v)
		}
	} else {
		fprintf(std.stderr(), "%s: missing key 'dependencies'\n", path)
		return false, {}
	}

	if ^[]any(r["include"]) != null {
		m.include = make([]str, len([]any(r["include"])))
		for i, v in []any(r["include"]) {
			m.include[i] = str(v)
		}
	} else {
		fprintf(std.stderr(), "%s: missing key 'include'\n", path)
		return false, {}
	}

	if ^str(r["run"]) != null {
		m.run = str(r["run"])
	}
	
	if ^str(r["run_posix"]) != null {
		m.runPosix = str(r["run_posix"])
	}

	if ^str(r["run_windows"]) != null {
		m.runWindows = str(r["run_windows"])
	}

	if ^str(r["pre_build"]) != null {
		m.preBuild = str(r["pre_build"])
	}

	if ^str(r["post_build"]) != null {
		m.postBuild = str(r["post_build"])
	}

	return true, m
}

type ApiResp* = struct {
	ok: bool
	status: int
	data: any
	msg: str
}

fn parseResp(r: io.Reader, resp: http.Response): ApiResp {
	if !resp.ok {
		return {
			ok: false,
			status: -1,
			msg: resp.err
		}
	}
		  
	out := ApiResp{}
	out.status = resp.status
	
	payload := json.parse(str([]char(r.read())))
	if errs := ^[]json.Error(payload); errs != null {
		out.ok = false
		out.status = -2
		for _, err in errs {
			out.msg += sprintf("(%d): %s\n", err.lno, err.message)
		}
		return out
	}
	
	if data := ^map[str]any(payload); data != null {
		out.ok = bool(data["ok"])
		if out.ok {
			out.data = data["data"]
		} else {
			out.msg = str(data["msg"])
		}
	} else {
		out.ok = false
		out.msg = "invalid json"
		out.status = -3
	}
	
	return out
}

fn get*(url, endpoint: str, token: str = ""): ApiResp {
	url = sprintf("%s/%s", url, endpoint)
	rw := io.mkMemory({})
	par := http.GetParams{
		userAgent: "umbox-cli"
	}
		 
	if len(token) > 0 {
		par.headers = append(par.headers, "Authorization: UmBox " + token)
	}
	
	return parseResp(rw, http.get(url, rw, par))
}

fn post*(data: io.Reader, url, endpoint: str, token: str = ""): ApiResp {
	url = sprintf("%s/%s", url, endpoint)
	rw := io.mkMemory({})
	par := http.PostParams{
		userAgent: "umbox-cli"
	}
		 
	if len(token) > 0 {
		par.headers = append(par.headers, "Authorization: UmBox " + token)
	}
	
	return parseResp(rw, http.post(url, data, rw, par))
}

fn download*(package, file: str): ([]uint8, bool, str) {
	w := io.mkMemory({})
	resp := http.get(sprintf("%s/api/package/%s/download/%s", url, package, file), w, {
		userAgent: "umbox-cli"
	})
	
	return w.read(), resp.ok && resp.status == 200, resp.err
}

fn exists*(package: str, file: str = "version"): bool {
	w := io.mkMemory({})
	resp := http.get(sprintf("%s/api/package/%s/download/%s", url, package, file), w, {
		userAgent: "umbox-cli"
	})

	return resp.ok && resp.status == 200
}
