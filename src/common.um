
import (
	"std.um"
	"../umbox/http/http.um"
	"../umbox/io/io.um"
	"../umbox/json/json.um"
	"../umbox/jsonenc/jsonenc.um"
	"../umbox/os/os.um"
	"../umbox/strings/strings.um"
	"../umbox/tar/tar.um"
)

var url*: str = "https://umbox.tophat2d.dev/"

type Box* = interface {
	exists(file: str = "version"): bool
	download(file: str = "box.tar"): ([]uint8, bool, str)
	encode(): str
	getName(): str
}

type HTTPBox* = struct {
	name: str
	url: str
}

fn (b: ^HTTPBox) getName*(): str {
	return b.name
}

fn (b: ^HTTPBox) exists*(file: str = "version"): bool {
	w := io.mkMemory({})
	resp := http.get(sprintf("%s/api/package/%s/download/%s", b.url, b.name, file), w, {
		userAgent: "umbox-cli"
	})

	return resp.ok && resp.status == 200
}

fn (b: ^HTTPBox) download*(file: str = "box.tar"): ([]uint8, bool, str) {
	w := io.mkMemory({})
	resp := http.get(sprintf("%s/api/package/%s/download/%s", b.url, b.name, file), w, {
		userAgent: "umbox-cli"
	})
	   
	msg := resp.err
	if resp.status != 200 {
		msg = str([]char(w.read()))
	}
	
	return w.read(), resp.ok && resp.status == 200, msg
}

fn (b: ^HTTPBox) encode*(): str {
	if b.url != "https://umbox.tophat2d.dev" {
		return sprintf("%s@%s", b.name, b.url)
	}
	
	return b.name
}

type FileBox* = struct {
	name: str
	path: str
	handle: tar.Tar
}

fn (b: ^FileBox) open(): tar.Errno {
	var err: tar.Errno
	b.handle, err = tar.open(b.path, "r")

	return err
}

fn (b: ^FileBox) getName*(): str {
	return b.name
}

fn (b: ^FileBox) exists*(file: str = "version"): bool {
	if b.handle._ == null {
		if err := b.open(); err != 0 {
			return false
		}
	}
	
	dat, err := b.handle.read(file)
	return err == 0
}

fn (b: ^FileBox) download*(file: str = "box.tar"): ([]uint8, bool, str) {
	if file == "box.tar" {
		f := std.fopen(b.path, "r")
		if f == null {
			return {}, false, "File not found"
		}
		d := io.mkFile(f).read()
		std.fclose(f)

		return d, true, ""
	}

	if b.handle._ == null {
		if err := b.open(); err != 0 {
			return {}, false, tar.strerror(err)
		}
	}

	dat, err := b.handle.read(file)
	if err != 0 {
		return {}, false, tar.strerror(err)
	}
	
	return dat, true, ""
}

fn (b: ^FileBox) encode*(): str {
	return sprintf("%s@file://%s", b.name, b.path)
}

type Meta* = struct {
	name: str
	version: str
	author: str
	license: str
	description: str
	readme: str
	link: str
	dependencies: []Box
	include: []str
	run: str
	runPosix: str
	runWindows: str
	preBuild: str
	postBuild: str
}

fn (m: ^Meta) toJSON*(): str {
	enc := jsonenc.mk()

	enc.startObject()
		enc.putKey("name"); enc.putVal(m.name)
		enc.putKey("version"); enc.putVal(m.version)
		enc.putKey("author"); enc.putVal(m.author)
		enc.putKey("license"); enc.putVal(m.license)
		enc.putKey("description"); enc.putVal(m.description)
		enc.putKey("readme"); enc.putVal(m.readme)
		enc.putKey("link"); enc.putVal(m.link)
		enc.putKey("dependencies"); enc.startArray()
			for i,v in m.dependencies {
				enc.putVal(v.encode())
			}
		enc.endArray()
			
		enc.putKey("include"); enc.startArray()
			for i,v in m.include {
				enc.putVal(v)
			}
		enc.endArray()
			
		if len(m.run) > 0 {
			enc.putKey("run"); enc.putVal(m.run)
		}

		if len(m.runPosix) > 0 {
			enc.putKey("run_posix"); enc.putVal(m.runPosix)
		}

		if len(m.runWindows) > 0 {
			enc.putKey("run_windows"); enc.putVal(m.runWindows)
		}

		if len(m.preBuild) > 0 {
			enc.putKey("pre_build"); enc.putVal(m.preBuild)
		}

		if len(m.postBuild) > 0 {
			enc.putKey("post_build"); enc.putVal(m.postBuild)
		}
	enc.endObject()

	return enc.toStr()
}

fn parseDep*(dep: str): Box {
	if !strings.contains(dep, "@") {
		return HTTPBox{
			name: dep,
			url: "https://umbox.tophat2d.dev"
		}
	}
	
	sp := strings.split(dep, "@")
	name := sp[0]
	source := sp[1]
	
	if strings.has_prefix(source, "http://") || strings.has_prefix(source, "https://") {
		return HTTPBox{
			name: name,
			url: source
		}
	} else if strings.has_prefix(source, "file://") {
		return FileBox{
			name: name,
			path: strings.trimprefix(source, "file://")
		}
	}
		
	return null
}

fn getMeta*(path: str): (bool, Meta) {
	if !os.isfile(path) {
		return false, {}
	}
	
	f := std.fopen(path, "r")
	r := ^map[str]any(json.parse(str([]char(io.mkFile(f).read()))))
	std.fclose(f)
	if r == null {
		return false, {}
	}
	   
	m := Meta{}

	if ^str(r["name"]) != null {
		m.name = str(r["name"])
	} else {
		fprintf(std.stderr(), "%s: missing key 'name'\n", path)
		return false, {}
	}
	
	if ^str(r["version"]) != null {
		m.version = str(r["version"])
	} else {
		fprintf(std.stderr(), "%s: missing key 'version'\n", path)
		return false, {}
	}
	
	if ^str(r["author"]) != null {
		m.author = str(r["author"])
	} else {
		fprintf(std.stderr(), "%s: missing key 'author'\n", path)
		return false, {}
	}

	if ^str(r["license"]) != null {
		m.license = str(r["license"])
	} else {
		fprintf(std.stderr(), "%s: missing key 'license'\n", path)
		return false, {}
	}

	if ^str(r["description"]) != null {
		m.description = str(r["description"])
	} else {
		fprintf(std.stderr(), "%s: missing key 'description'\n", path)
		return false, {}
	}

	if ^str(r["readme"]) != null {
		m.readme = str(r["readme"])
	} else {
		fprintf(std.stderr(), "%s: missing key 'readme'\n", path)
		return false, {}
	}

	if ^str(r["link"]) != null {
		m.link = str(r["link"])
	} else {
		fprintf(std.stderr(), "%s: missing key 'link'\n", path)
		return false, {}
	}

	if ^[]any(r["dependencies"]) != null {
		m.dependencies = make([]Box, len([]any(r["dependencies"])))
		for i, v in []any(r["dependencies"]) {
			m.dependencies[i] = parseDep(str(v))
			if !valid(m.dependencies[i]) {
				fprintf(std.stderr(), "Malformed dependency %s\n", str(v))
				return false, {}
			}
		}
	} else {
		fprintf(std.stderr(), "%s: missing key 'dependencies'\n", path)
		return false, {}
	}

	if ^[]any(r["include"]) != null {
		m.include = []str([]any(r["include"]))
	} else {
		fprintf(std.stderr(), "%s: missing key 'include'\n", path)
		return false, {}
	}

	if ^str(r["run"]) != null {
		m.run = str(r["run"])
	}
	
	if ^str(r["run_posix"]) != null {
		m.runPosix = str(r["run_posix"])
	}

	if ^str(r["run_windows"]) != null {
		m.runWindows = str(r["run_windows"])
	}

	if ^str(r["pre_build"]) != null {
		m.preBuild = str(r["pre_build"])
	}

	if ^str(r["post_build"]) != null {
		m.postBuild = str(r["post_build"])
	}

	return true, m
}

type ApiResp* = struct {
	ok: bool
	status: int
	data: any
	msg: str
}

fn parseResp(r: io.Reader, resp: http.Response): ApiResp {
	if !resp.ok {
		return {
			ok: false,
			status: -1,
			msg: resp.err
		}
	}
		  
	out := ApiResp{}
	out.status = resp.status
	
	payload := json.parse(str([]char(r.read())))
	if errs := ^[]json.Error(payload); errs != null {
		out.ok = false
		out.status = -2
		for _, err in errs {
			out.msg += sprintf("(%d): %s\n", err.lno, err.message)
		}
		return out
	}
	
	if data := ^map[str]any(payload); data != null {
		out.ok = bool(data["ok"])
		if out.ok {
			out.data = data["data"]
		} else {
			out.msg = str(data["msg"])
		}
	} else {
		out.ok = false
		out.msg = "invalid json"
		out.status = -3
	}
	
	return out
}

fn get*(url, endpoint: str, token: str = ""): ApiResp {
	url = sprintf("%s/%s", url, endpoint)
	rw := io.mkMemory({})
	par := http.GetParams{
		userAgent: "umbox-cli"
	}
		 
	if len(token) > 0 {
		par.headers = append(par.headers, "Authorization: UmBox " + token)
	}
	
	return parseResp(rw, http.get(url, rw, par))
}

fn post*(data: io.Reader, url, endpoint: str, token: str = ""): ApiResp {
	url = sprintf("%s/%s", url, endpoint)
	rw := io.mkMemory({})
	par := http.PostParams{
		userAgent: "umbox-cli"
	}
		 
	if len(token) > 0 {
		par.headers = append(par.headers, "Authorization: UmBox " + token)
	}
	
	return parseResp(rw, http.post(url, data, rw, par))
}