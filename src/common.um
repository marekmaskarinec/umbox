
import (
	"std.um"
	"../umbox/json/json.um"
	"../umbox/jsonenc/jsonenc.um"
	"../umbox/os/os.um"
	"../umbox/strings/strings.um"
	"../umbox/filepath/filepath.um"
)

type ErrCode* = enum {
	ok
	failed
	cli
	json
	boxNotFound
	fileNotFound
	jsonKeyNotFound
	boxJsonError
	buildError
	gitError
	command
}

var errStrings: []str = []str{
	"not an error",
	"failed",
	"invalid cli arguments",
	"json error",
	"box not found",
	"file not found",
	"json key not found",
	"box.json error",
	"build error",
	"git error",
	"external command error"
}

fn error*(ec: ErrCode, msg: str = ""): std::Err {
	e := std::error(int(ec), errStrings[int(ec)], "umbox")
	if msg != "" {
		e.msg += ": " + msg
	}
	return e
}

var serverUrl*: str = "https://umbox.tophat2d.dev/"
var debugMode*: bool = false

fn exitif*(e: std::Err) {
	if e.code == 0 {
		return
	}

	if debugMode {
		std::exitif(e)
	}

	fprintf(std::stderr(), "UmBox error (%d): %s\n", e.code, e.msg)
	exit(1)
}

fn copyr*(src, dst: str): std::Err {
	copyFile := fn(src, dst: str): std::Err {
		os::mkdirp(filepath::dir(dst))
		f1, err := std::fopen(src, "rb")
		d, err := std::freadall(f1)
		f2, err := std::fopen(dst, "wb")
		std::fwrite(f2, d)
		std::fclose(f1)
		std::fclose(f2)	
		
		return {}
	}
			  
	if os::isfile(src) {
		return copyFile(src, dst)
	}

	return os::walk(src, |copyFile, src, dst| {
		file2 := filepath::join(dst, strings::trimprefix(file, src))
		copyFile(file, file2)
	}, { excludeDirs: true })
}

type PlatString* = map[os::Platform]str

fn (ps: ^PlatString) getByPlatform*(plat: os::Platform): str {
	if validkey(ps^, plat) {
		return ps[plat]
	}
	
	return ps[.unknown]
}

fn (ps: ^PlatString) get*(): str {
	return ps.getByPlatform(os::getPlatform())
}

type (
	Target* = struct {
		sources: []str
		cflags: PlatString
		ldflags: PlatString
	}

	Build* = struct {
		isValid: bool
		pre: PlatString
		post: PlatString
		include: []str
		targets: map[str]Target
	}
)

type Dep* = struct {
	full: str
	url: str
	ref: str
	name: str
	canonical: str
	srcPath: str
	dstPath: str
	buildOnly: bool
}

type Meta* = struct {
	name: str
	author: str
	description: str
	source: str
	homepage: str
	run: PlatString
	others: map[str]any
	build: Build
	deps: []Dep
}

fn putPlatString(enc: ^jsonenc::Encoder, ps: PlatString) {
	simple := true
	for k,v in ps {
		if k != .unknown {
			simple = false
			break
		}
	}

	if simple {
		enc.putVal(ps[.unknown])
		return
	}

	enc.startObject()
		for k,v in ps {
			switch k {
			case .unknown: continue
			case .windows: enc.putKey("windows")
			case .posix: enc.putKey("posix")
			case .emscripten: enc.putKey("emscripten")
			}

			enc.putVal(v)
		}
	enc.endObject()
}

fn (m: ^Meta) toJSON*(): str {
	enc := jsonenc::mk()

	enc.startObject()
		enc.putKey("name"); enc.putVal(m.name)
		enc.putKey("author"); enc.putVal(m.author)
		enc.putKey("description"); enc.putVal(m.description)

		if len(m.source) > 0 {
			enc.putKey("source"); enc.putVal(m.source)
		}

		if len(m.homepage) > 0 {
			enc.putKey("homepage"); enc.putVal(m.homepage)
		}
			
		if len(m.run) > 0 {
			enc.putKey("run"); putPlatString(&enc, m.run)
		}

		if len(keys(m.others)) > 0 {
			for k,v in m.others {
				if valid(v) {
					enc.putKey(k)
					enc.putVal(v)
				}
			}
		}
	enc.endObject()

	return enc.toStr()
}

fn getPlatString(o: any): (PlatString, std::Err) {
	if s := ^str(o); s != null {
		return { .unknown: s^ }, {}
	}
	
	obj := ^map[str]any(o)
	if obj == null {
		printf("%v\n", o)
		return {}, error(.json, "invalid platform string")
	}
  
	ps := PlatString{}
	for k, v in obj {
		if ^str(v) == null {
			return {}, error(.json, sprintf("invalid platform value: %s", k))
		}

		if k == "unknown" {
			ps[.unknown] = str(v)
		} else if k == "windows" {
			ps[.windows] = str(v)
		} else if k == "posix" {
			ps[.posix] = str(v)
		} else if k == "emscripten" {
			ps[.emscripten] = str(v)
		} else {
			return {}, error(.json, sprintf("invalid platform key: %s", k))
		}
	}
	
	return ps, {}
}

fn parseBuild*(o: map[str]any): (Build, std::Err) {
	var err: std::Err
	b := Build{
		isValid: true
	}
	   
	if validkey(o, "pre") {
		b.pre, err = getPlatString(o["pre"])
		if err.code != 0 {
			return {}, err
		}
	}	
	
	if validkey(o, "post") {
		b.post, err = getPlatString(o["post"])
		if err.code != 0 {
			return {}, err
		}
	}
	
	if arr := ^[]any(o["include"]); arr != null {
		b.include = make([]str, len(arr^))
		for i,a in arr {
			if ^str(a) == null {
				return {}, error(.boxJsonError, sprintf("include '%v' is not a string", a))
			}
			b.include[i] = str(a)
		}
	}
	
	if ^map[str]any(o["targets"]) != null {
		b.targets = map[str]Target{}
		for k, v in map[str]any(o["targets"]) {
			vo := map[str]any(v)
			t := Target{}
			if ^[]any(vo["sources"]) != null {
				t.sources = []str([]any(vo["sources"]))
			} else if ^str(vo["sources"]) != null {
				t.sources = []str{str(vo["sources"])}
			}
			
			if validkey(vo, "cflags") {
				t.cflags, err = getPlatString(vo["cflags"])
				if err.code != 0 {
					return {}, err
				}
			}
			
			if validkey(vo, "ldflags") {
				t.ldflags, err = getPlatString(vo["ldflags"])
				if err.code != 0 {
					return {}, err
				}
			}
			
			b.targets[k] = t
		}
	}
	
	return b, {}
}

fn getDeps(meta: ^map[str]any): ([]Dep, std::Err) {
	deps := []Dep{}
	src := []any{}

	if a := ^[]any(meta["deps"]); a != null {
		src = a^
	} else {
		printf("warning: invalid or missing deps field\n")
	}

	buildCut := len(src)

	if a := ^[]any(meta["buildDeps"]); a != null {
		src = append(src, a^)
	}

	for i,a in src {
		if ^str(a) == null {
			return {}, error(.boxJsonError, sprintf("dependency '%v' is not a string", a))
		}

		d := Dep{}
		d.full = str(a)
		split := strings::split(d.full, "@")
		if len(split) < 2 {
			return {}, error(.boxJsonError, sprintf("invalid dependency '%s'", d.full))
		}
		d.url = strings::join(slice(split, 0, len(split) - 1), "@")
		d.ref = split[len(split) - 1]
		d.canonical = strings::replace(d.full, "/", "_")
		d.name = filepath::file(d.url)
		d.srcPath = filepath::join("umbox", "src", d.canonical)
		d.dstPath = filepath::join("umbox", "dst", d.canonical)
		d.buildOnly = i >= buildCut

		deps = append(deps, d)
	}
	
	return deps, {}
}

fn getMeta*(path: str): (Meta, std::Err) {
	if !os::isfile(path) {
		return {}, error(.fileNotFound, path)
	}
	
	f, err := std::fopen(path, "rb")
	if err.code != 0 {
		return {}, err
	}

	d, err := std::freadall(f)
	if err.code != 0 {
		return {}, err
	}

	parsed := json::parse(str(d))
	std::fclose(f)
	if errs := ^[]json::Error(parsed); errs != null {
		return {}, error(.json, sprintf("(%s:%d) %s", path, errs[0].lno, errs[0].message))
	}

	r := ^map[str]any(parsed)
	if r == null {
		return {}, error(.json, "invalid top level json object")
	}
	   
	m := Meta{}

	if ^str(r["name"]) != null {
		m.name = str(r["name"])
		r ^= delete(r^, "name")
	} else {
		return {}, error(.jsonKeyNotFound, "name")
	}
	
	if ^str(r["author"]) != null {
		m.author = str(r["author"])
		r ^= delete(r^, "author")
	} else {
		return {}, error(.jsonKeyNotFound, "author")
	}

	if ^str(r["description"]) != null {
		m.description = str(r["description"])
		r ^= delete(r^, "description")
	} else {
		return {}, error(.jsonKeyNotFound, "description")
	}

	if ^str(r["source"]) != null {
		m.source = str(r["source"])
		r ^= delete(r^, "source")
	}

	if ^str(r["homepage"]) != null {
		m.homepage = str(r["homepage"])
		r ^= delete(r^, "homepage")
	}

	if validkey(r^, "run") {
		var err: std::Err
		m.run, err = getPlatString(r["run"])
		if err.code != 0 {
			return {}, err
		}
		r ^= delete(r^, "run")
	}

	m.deps, err = getDeps(r)
	if err.code != 0 {
		return {}, err
	}
	
	if ^map[str]any(r["build"]) != null {
		m.build, err = parseBuild(map[str]any(r["build"]))
		if err.code != 0 {
			return {}, err
		}

		r ^= delete(r^, "build")
	}

	m.others = r^

	return m, {}
}