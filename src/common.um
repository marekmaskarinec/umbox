
import (
	"std.um"
	"../umbox/http/http.um"
	"../umbox/json/json.um"
	"../umbox/jsonenc/jsonenc.um"
	"../umbox/os/os.um"
	"../umbox/strings/strings.um"
	"../umbox/tar/tar.um"
)

var serverUrl*: str = "https://umbox.tophat2d.dev/"
var debugMode*: bool = false

fn exitif*(e: std.Err) {
	if e.code == 0 {
		return
	}

	if debugMode {
		std.exitif(e)
	}

	fprintf(std.stderr(), "UmBox error: %s (code %d)\n", e.msg, e.code)
	exit(1)
}

type Box* = interface {
	exists(file: str = "version"): bool
	download(file: str = "box.tar"): ([]char, std.Err)
	encode(): str
	getName(): str
}

type HTTPBox* = struct {
	name: str
	url: str
}

fn (b: ^HTTPBox) getName*(): str {
	return b.name
}

fn (b: ^HTTPBox) exists*(file: str = "version"): bool {
	resp := http.get(sprintf("%s/api/package/%s/download/%s", b.url, b.name, file), {
		userAgent: "umbox-cli"
	})

	return resp.ok && resp.status == 200
}

fn (b: ^HTTPBox) download*(file: str = "box.tar"): ([]char, std.Err) {
	resp := http.get(sprintf("%s/api/package/%s/download/%s", b.url, b.name, file), {
		userAgent: "umbox-cli"
	})

	if !resp.ok {
		return {}, std.error(1, resp.err)
	}

	if resp.status != 200 {
		return resp.body, std.error(resp.status, str(resp.body))
	}

	return resp.body, {}
}

fn (b: ^HTTPBox) encode*(): str {
	if b.url != serverUrl {
		return sprintf("%s@%s", b.name, b.url)
	}
	
	return b.name
}

type FileBox* = struct {
	name: str
	path: str
	handle: tar.Tar
}

fn (b: ^FileBox) open(): std.Err {
	var err: std.Err
	b.handle, err = tar.open(b.path, "r")

	return err
}

fn (b: ^FileBox) getName*(): str {
	return b.name
}

fn (b: ^FileBox) exists*(file: str = "version"): bool {
	if file == "version" {
		return os.isfile(b.path)
	}

	if b.handle._ == null {
		if err := b.open(); err.code != 0 {
			return false
		}
	}
	
	dat, err := b.handle.read(file)
	return err.code == 0
}

fn (b: ^FileBox) download*(file: str = "box.tar"): ([]char, std.Err) {
	if file == "box.tar" {
		f, err := std.fopen(b.path, "rb")
		if err.code != 0 {
			return {}, err
		}
		d, err := std.freadall(f)
		if err.code != 0 {
			return {}, err
		}
		std.fclose(f)

		return d, {}
	}
	
	if file == "version" {
		sb, err := os.stat(b.path)
		if err.code != 0 {
			return {}, err
		}
		
		return []char(std.itoa(sb.mtime)), {}
	}

	if b.handle._ == null {
		if err := b.open(); err.code != 0 {
			return {}, err
		}
	}

	dat, err := b.handle.read(file)
	if err.code != 0 {
		return {}, err
	}
	
	return dat, {}
}

fn (b: ^FileBox) encode*(): str {
	return sprintf("%s@file://%s", b.name, b.path)
}

type Meta* = struct {
	name: str
	version: str
	author: str
	license: str
	description: str
	readme: str
	link: str
	dependencies: []Box
	include: []str
	run: str
	runPosix: str
	runWindows: str
	preBuild: str
	postBuild: str
}

fn (m: ^Meta) toJSON*(): str {
	enc := jsonenc.mk()

	enc.startObject()
		enc.putKey("name"); enc.putVal(m.name)
		enc.putKey("version"); enc.putVal(m.version)
		enc.putKey("author"); enc.putVal(m.author)
		enc.putKey("license"); enc.putVal(m.license)
		enc.putKey("description"); enc.putVal(m.description)
		enc.putKey("readme"); enc.putVal(m.readme)
		enc.putKey("link"); enc.putVal(m.link)
		enc.putKey("dependencies"); enc.startArray()
			for i,v in m.dependencies {
				enc.putVal(v.encode())
			}
		enc.endArray()
			
		enc.putKey("include"); enc.startArray()
			for i,v in m.include {
				enc.putVal(v)
			}
		enc.endArray()
			
		if len(m.run) > 0 {
			enc.putKey("run"); enc.putVal(m.run)
		}

		if len(m.runPosix) > 0 {
			enc.putKey("run_posix"); enc.putVal(m.runPosix)
		}

		if len(m.runWindows) > 0 {
			enc.putKey("run_windows"); enc.putVal(m.runWindows)
		}

		if len(m.preBuild) > 0 {
			enc.putKey("pre_build"); enc.putVal(m.preBuild)
		}

		if len(m.postBuild) > 0 {
			enc.putKey("post_build"); enc.putVal(m.postBuild)
		}
	enc.endObject()

	return enc.toStr()
}

fn parseDep*(dep: str): Box {
	if !strings.contains(dep, "@") {
		return HTTPBox{
			name: dep,
			url: serverUrl
		}
	}
	
	sp := strings.split(dep, "@")
	name := sp[0]
	source := sp[1]
	
	if strings.has_prefix(source, "http://") || strings.has_prefix(source, "https://") {
		return HTTPBox{
			name: name,
			url: source
		}
	} else if strings.has_prefix(source, "file://") {
		return FileBox{
			name: name,
			path: strings.trimprefix(source, "file://")
		}
	}
		
	return null
}

fn getMeta*(path: str): (Meta, std.Err) {
	if !os.isfile(path) {
		return {}, std.error(1, "file not found", path)
	}
	
	f, err := std.fopen(path, "rb")
	if err.code != 0 {
		return {}, err
	}

	d, err := std.freadall(f)
	if err.code != 0 {
		return {}, err
	}

	parsed := json.parse(str(d))
	std.fclose(f)
	if errs := ^[]json.Error(parsed); errs != null {
		return {}, std.error(1, sprintf("json parser error: %d %s", errs[0].message, errs[0].lno), path)
	}

	r := ^map[str]any(parsed)
	if r == null {
		return {}, std.error(1, "invalid top level json object", path)
	}
	   
	m := Meta{}

	if ^str(r["name"]) != null {
		m.name = str(r["name"])
	} else {
		return {}, std.error(1, "missing key 'name'", path)
	}
	
	if ^str(r["version"]) != null {
		m.version = str(r["version"])
	} else {
		return {}, std.error(1, "missing key 'version'", path)
	}
	
	if ^str(r["author"]) != null {
		m.author = str(r["author"])
	} else {
		return {}, std.error(1, "missing key 'author'", path)
	}

	if ^str(r["license"]) != null {
		m.license = str(r["license"])
	} else {
		return {}, std.error(1, "missing key 'license'", path)
	}

	if ^str(r["description"]) != null {
		m.description = str(r["description"])
	} else {
		return {}, std.error(1, "missing key 'description'", path)
	}

	if ^str(r["readme"]) != null {
		m.readme = str(r["readme"])
	} else {
		return {}, std.error(1, "missing key 'readme'", path)
	}

	if ^str(r["link"]) != null {
		m.link = str(r["link"])
	} else {
		return {}, std.error(1, "missing key 'link'", path)
	}

	if ^[]any(r["dependencies"]) != null {
		m.dependencies = make([]Box, len([]any(r["dependencies"])))
		for i, v in []any(r["dependencies"]) {
			m.dependencies[i] = parseDep(str(v))
			if !valid(m.dependencies[i]) {
				return {}, std.error(1, sprintf("malformed dependency %s", str(v)), path)
			}
		}
	} else {
		return {}, std.error(1, "missing key 'dependencies'", path)
	}

	if ^[]any(r["include"]) != null {
		m.include = []str([]any(r["include"]))
	} else {
		return {}, std.error(1, "missing key 'include'", path)
	}

	if ^str(r["run"]) != null {
		m.run = str(r["run"])
	}
	
	if ^str(r["run_posix"]) != null {
		m.runPosix = str(r["run_posix"])
	}

	if ^str(r["run_windows"]) != null {
		m.runWindows = str(r["run_windows"])
	}

	if ^str(r["pre_build"]) != null {
		m.preBuild = str(r["pre_build"])
	}

	if ^str(r["post_build"]) != null {
		m.postBuild = str(r["post_build"])
	}

	return m, {}
}

type ApiResp* = struct {
	ok: bool
	status: int
	data: any
	msg: str
}

fn parseResp(resp: http.Response): ApiResp {
	if !resp.ok {
		return {
			ok: false,
			status: -1,
			msg: resp.err
		}
	}
		  
	out := ApiResp{}
	out.status = resp.status
	
	payload := json.parse(str(resp.body))
	if errs := ^[]json.Error(payload); errs != null {
		out.ok = false
		out.status = -2
		for _, err in errs {
			out.msg += sprintf("(%d): %s\n", err.lno, err.message)
		}
		return out
	}
	
	if data := ^map[str]any(payload); data != null {
		out.ok = bool(data["ok"])
		if out.ok {
			out.data = data["data"]
		} else {
			out.msg = str(data["msg"])
		}
	} else {
		out.ok = false
		out.msg = "invalid json"
		out.status = -3
	}
	
	return out
}

fn get*(url, endpoint: str, token: str = ""): ApiResp {
	url = sprintf("%s/%s", url, endpoint)
	par := http.GetParams{
		userAgent: "umbox-cli"
	}
		 
	if len(token) > 0 {
		par.headers = append(par.headers, "Authorization: UmBox " + token)
	}
	
	return parseResp(http.get(url, par))
}

fn post*(data: []char, url, endpoint: str, token: str = ""): ApiResp {
	url = sprintf("%s/%s", url, endpoint)
	par := http.PostParams{
		userAgent: "umbox-cli"
	}
		 
	if len(token) > 0 {
		par.headers = append(par.headers, "Authorization: UmBox " + token)
	}
	
	return parseResp(http.post(url, data, par))
}
