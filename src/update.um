
import (
	"../umbox/os/os.um"	
	"../umbox/json/json.um"
	"../umbox/filepath/filepath.um"
	"../umbox/tar/tar.um"
	"../umbox/io/io.um"
	"../umbox/jsonenc/jsonenc.um"

	"std.um"
	"common.um"
)

fn fetchDeps(deps: []str, versions: ^map[str]str)

fn fetchDep(dep: str, versions: ^map[str]str) {
	if !common.exists(dep) {
		printf("No such package: %s\n", dep)
		exit()
	}
	
	os.mkdirp(filepath.join("umbox", dep))
		
	// fetch box.json
	umboxjson := str([]char(common.download(dep, "box.json")))
	f := std.fopen(filepath.join("umbox", dep, "box.json"), "w")
	fprintf(f, "%s", umboxjson)
	std.fclose(f)
	
	// fetch and extract box.tar
	tf, err := tar.openBytes(common.download(dep, "box.tar"))
	if err != 0 {
		printf("Error parsing box.tar: %s\n", tar.strerror(err))
		exit()
	}
	
	err = tf.extract(filepath.join("umbox", dep, ""))
	if err != 0 {
		printf("Error extracting box.tar: %s\n", tar.strerror(err))
		exit()
	}
	
	// Fetch dependencies
	ok, meta := common.getMeta(filepath.join("umbox", dep, "box.json"))
	if !ok {
		printf("Error parsing %s\n", filepath.join("umbox", dep, "box.json"))
		exit()
	}
	fetchDeps(meta.dependencies, versions)
	
	// Create symlinks for dependencies
	os.mkdirp(filepath.join("umbox", dep, "umbox"))
	for i,d in meta.dependencies {
		err := os.link(filepath.join("..", "..", d), filepath.join("umbox", dep, "umbox", d))
		if err != 0 && os.getPlatform() == os.PlatformWindows {
			std.system("mklink /j " + filepath.join("umbox", dep, "umbox", d) + " " + filepath.join("umbox", d))
		}
	}
	      
	versions[dep] = str([]char(common.download(dep, "version")))
}

fn fetchDeps(deps: []str, versions: ^map[str]str) {
	for i,dep in deps {
		// If the dependency doesn't exist, fetch it.
		if !os.isdir(filepath.join("umbox", dep)) {
			printf("Downloading %s...\n", dep)
			fetchDep(dep, versions)
			continue
		}

		// If the dependency doesn't have a known version, fetch it.
		if !validkey(versions^, dep) {
			printf("Downloading %s...\n", dep)
			fetchDep(dep, versions)
			continue
		}

		// Check for new versions.
		if versions[dep] != str([]char(common.download(dep, "version"))) {
			printf("Updating %s...\n", dep)
			fetchDep(dep, versions)
			continue
		}
	}
}

fn touchDep(dep: str, touched: ^map[str]bool) {
	if validkey(touched^, dep) {
		return
	}

	touched[dep] = true

	ok, meta := common.getMeta(filepath.join("umbox", dep, "box.json"))
	if !ok {
		return
	}

	for i, dep in meta.dependencies {
		touchDep(dep, touched)
	}
}

fn run*(url: str, argi: int) {
	if argi != std.argc() {
		printf("Too many arguments.\n")
		return
	}

	ok, meta := common.getMeta("box.json")
	if !ok {
		printf("Not in an UmBox directory.\n")
		return
	}
	
	os.mkdirp("umbox")

	versions := map[str]str{}
	if os.isfile(filepath.join("umbox", "versions.json")) {
		f := std.fopen(filepath.join("umbox", "versions.json"), "r")
		r := map[str]any(json.parse(str([]char(io.mkFile(f).read()))))
		std.fclose(f)
		for k,v in r {
			versions[k] = str(v)
		}
	}

	fetchDeps(meta.dependencies, &versions)

	touched := map[str]bool{}
	for i,dep in meta.dependencies {
		touchDep(dep, &touched)
	}
		
	enc := jsonenc.mk(true)
	enc.startObject()
	for k,v in versions {
		if touched[k] {
			enc.putKey(k)
			enc.putVal(v)
		}
	}
	enc.endObject()

	f := std.fopen(filepath.join("umbox", "versions.json"), "w")
	fprintf(f, "%s", enc.toStr())
	std.fclose(f)
	
	ls, _ := os.listdir("umbox")
	for i,d in ls {
		if d == "versions.json" || d == "." || d == ".." {
			continue
		}

		if !touched[d] {
			printf("Removing %s...\n", d)
			os.walk(filepath.join("umbox", d), fn(path: str) |d| {
				err := os.remove(path)
				if err != 0 {
					printf("Error removing %s: %s\n", path, os.strerror(err))
				}
			}, { skipLinks: true })
			
			os.remove(filepath.join("umbox", d))
		}
	}
}
