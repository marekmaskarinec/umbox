
import (
	"../umbox/os/os.um"	
	"../umbox/json/json.um"
	"../umbox/filepath/filepath.um"
	"../umbox/tar/tar.um"
	"../umbox/io/io.um"
	"../umbox/jsonenc/jsonenc.um"
	"../umbox/strings/strings.um"

	"std.um"
	"common.um"
)

fn fetchDeps(deps: []common.Box, versions: ^map[str]str)

var (
	copyDeps: bool = false
)

fn copyFile(p1, p2: str) {
	f1 := std.fopen(p1, "rb")
	r := io.mkFile(f1)
	f2 := std.fopen(p2, "wb")
	w := io.mkFile(f2)

	w.write(r.read())

	std.fclose(f1)
	std.fclose(f2)
}

fn fetchDep(dep: common.Box, versions: ^map[str]str) {
	if !dep.exists() {
		fprintf(std.stderr(), "No such package: %s\n", dep)
		exit()
	}
	
	os.mkdirp(filepath.join("umbox", dep.getName()))

	// fetch and extract box.tar
	d, ok, msg := dep.download("box.tar")
	if !ok {
		error(msg)
	}
	tf, err := tar.openBytes(d)
	if err != 0 {
		fprintf(std.stderr(), "Error parsing box.tar: %s\n", tar.strerror(err))
		exit()
	}
	
	err = tf.extract(filepath.join("umbox", dep.getName(), ""))
	if err != 0 {
		fprintf(std.stderr(), "Error extracting box.tar: %s\n", tar.strerror(err))
		exit()
	}
	
	// Fetch dependencies
	ok, meta := common.getMeta(filepath.join("umbox", dep.getName(), "box.json"))
	if !ok {
		fprintf(std.stderr(), "Error parsing %s\n", filepath.join("umbox", dep.getName(), "box.json"))
		exit()
	}
	fetchDeps(meta.dependencies, versions)

	// Create symlinks for dependencies
	os.mkdirp(filepath.join("umbox", dep.getName(), "umbox"))
	for i,d in meta.dependencies {
		if copyDeps {
			os.walk(filepath.join("umbox", d.getName()), |dep, d| {
				file2 := filepath.join(
					"umbox", dep.getName(), "umbox", d.getName(),
					strings.trimprefix(file, filepath.join("umbox", d.getName()))
				)

				os.mkdirp(filepath.dir(file2))
				copyFile(file, file2)
			}, { excludeDirs: true })
		} else {
			err := os.link(filepath.join("..", "..", d.getName()), filepath.join("umbox", dep.getName(), "umbox", d.getName()))
			if err != 0 && os.getPlatform() == os.PlatformWindows {
				std.system("mklink /j " + filepath.join("umbox", dep.getName(), "umbox", d.getName()) + " " + filepath.join("umbox", d.getName()))
			}
		}
	}

	{
		d, ok, msg := dep.download("version")
		if !ok {
			error(msg)
		}
		versions[dep.getName()] = str([]char(d))
	}
}

fn fetchDeps(deps: []common.Box, versions: ^map[str]str) {
	for i,dep in deps {
		// If the dependency doesn't exist, fetch it.
		if !os.isdir(filepath.join("umbox", dep.getName())) {
			fprintf(std.stderr(), "Downloading %s...\n", dep.getName())
			fetchDep(dep, versions)
			continue
		}

		// If the dependency doesn't have a known version, fetch it.
		if !validkey(versions^, dep.getName()) {
			fprintf(std.stderr(), "Downloading %s...\n", dep.getName())
			fetchDep(dep, versions)
			continue
		}

		// Check for new versions.
		{
			d, ok, msg := dep.download("version")
			if !ok {
				error(msg)
			}
			if versions[dep.getName()] != str([]char(d)) {
				fprintf(std.stderr(), "Updating %s...\n", dep.getName())
				fetchDep(dep, versions)
				continue
			}
		}
	}
}

fn touchDep(dep: str, touched: ^map[str]bool) {
	if validkey(touched^, dep) {
		return
	}

	touched[dep] = true

	ok, meta := common.getMeta(filepath.join("umbox", dep, "box.json"))
	if !ok {
		return
	}

	for i, dep in meta.dependencies {
		touchDep(dep.getName(), touched)
	}
}

fn run*(url: str, argi: int) {
	for argi < std.argc() {
		v := std.argv(argi)

		if v == "-c" {
			copyDeps = true
			printf("NOTE: The -c flag is experimental. It is advised to always remove the umbox/\ndirectory before running update with this flag\n")
		} else {
			printf("usage: umbox update [ -c ]\n  -c: Don't use symlinks\n")
			return
		}

		argi++
	}

	ok, meta := common.getMeta("box.json")
	if !ok {
		fprintf(std.stderr(), "Not in an UmBox directory.\n")
		return
	}
	
	os.mkdirp("umbox")

	versions := map[str]str{}
	if os.isfile(filepath.join("umbox", "versions.json")) {
		f := std.fopen(filepath.join("umbox", "versions.json"), "r")
		r := map[str]any(json.parse(str([]char(io.mkFile(f).read()))))
		std.fclose(f)
		for k,v in r {
			versions[k] = str(v)
		}
	}

	fetchDeps(meta.dependencies, &versions)

	touched := map[str]bool{}
	for i,dep in meta.dependencies {
		touchDep(dep.getName(), &touched)
	}
		
	enc := jsonenc.mk(true)
	enc.startObject()
	for k,v in versions {
		if touched[k] {
			enc.putKey(k)
			enc.putVal(v)
		}
	}
	enc.endObject()

	f := std.fopen(filepath.join("umbox", "versions.json"), "w")
	fprintf(f, "%s", enc.toStr())
	std.fclose(f)
	
	ls, _ := os.listdir("umbox")
	for i,d in ls {
		if d == "versions.json" || d == "." || d == ".." {
			continue
		}

		if !touched[d] {
			fprintf(std.stderr(), "Removing %s...\n", d)
			os.walk(filepath.join("umbox", d), fn(path: str) |d| {
				err := os.remove(path)
				if err != 0 {
					fprintf(std.stderr(), "Error removing %s: %s\n", path, os.strerror(err))
				}
			}, { skipLinks: true })
			
			os.remove(filepath.join("umbox", d))
		}
	}
}
