
import (
	"std.um"

	"../umbox/filepath/filepath.um"
	"../umbox/os/os.um"
	"../umbox/strings/strings.um"

	"common.um"
)

type Params* = struct {
	platformTag: bool
	winCross: bool
	outDir: str
	link: bool
}

fn (par: ^Params) addFile(p1: str): std::Err {
	p2 := filepath::join(par.outDir, p1)
	os::mkdirp(filepath::dir(p2))
	f1, err := std::fopen(p1, "rb")
	d, err := std::freadall(f1)
	f2, err := std::fopen(p2, "wb")
	std::fwrite(f2, d)
	std::fclose(f1)
	std::fclose(f2)

	return {} // TODO
}

fn (par: ^Params) shouldRebuild(target: str, sources: []str): bool {
	target = filepath::join(par.outDir, target)

	if !os::isfile(target) {
		return true
	}
	
	tstat, err := os::stat(target)
	if err.code != 0 {
		return true
	}
	
	for i in sources {
		sstat, err := os::stat(sources[i])
		if err.code != 0 {
			return true
		}
		
		if sstat.mtime > tstat.mtime {
			return true
		}
	}
	
	return false
}

fn (par: ^Params) buildCmd(cc, ldflags, cflags, out: str, sources: []str): str {
	return sprintf("%s -shared %s -o %s %s %s",
		cc,
		ldflags,
		filepath::join(par.outDir, out),
		cflags,
		strings::join(sources, " "))
}

fn tagTarget(path: str, plat: os::Platform): str {
	suffix := ".umi"
	switch plat {
	case .posix: suffix = "_linux.umi"
	case .windows: suffix = "_windows.umi"
	case .emscripten: suffix = "_emscripten.umi"
	}

	return strings::trimsuffix(path, ".umi") + suffix
}

fn (par: ^Params) compileUMI(cc: str, path: str, target: common::Target, plat: os::Platform): std::Err {
	if par.platformTag {
		path = tagTarget(path, plat)
	}

	rebuild := par.shouldRebuild(path, target.sources)
	if !rebuild {
		if common::debugMode { printf("No need to rebuild %s\n", path) }
		return {}
	}

	command := par.buildCmd(
		cc,
		target.ldflags.getByPlatform(plat),
		target.cflags.getByPlatform(plat),
		path,
		target.sources)
	os::mkdirp(filepath::dir(filepath::join(par.outDir, path)))
	printf("+ %s\n", command)
	rc := std::system(command)
	if rc != 0 {
		return common::error(.buildError, sprintf("build for %s exited with code %d", path, rc))
	}
	
	return {}
}

fn (par: ^Params) buildTargets(meta: common::Meta): std::Err {
	cc := std::getenv("CC")
	if cc == "" {
		cc = "cc"
	}

	for path,target in meta.build.targets {
		if filepath::ext(path) != "umi" {
			printf("Warning: Only .umi files are supported, skipping %s\n", path)
			continue
		}

		err := par.compileUMI(cc, path, target, os::getPlatform())
		if err.code != 0 {
			return err
		}

		if (par.winCross) {
			err = par.compileUMI("x86_64-w64-mingw32-gcc", path, target, .windows)
			if err.code != 0 {
				return err
			}
		}
	}

	return {}
}

var built: map[str]bool

fn link(target, link: str): std::Err {
	os::mkdirp(filepath::dir(link))
	err := os::link(target, link)
	if err.code != 0 && os::getPlatform() == os::Platform.windows {
		std::system("mklink /j " + target + " " + link)
		return {}
	}

	if err.code == 17 {
		return {}
	}
	return err
}

fn build*(par: Params): std::Err {
	if built[os::getCwd().item0] {
		return {}
	}

	printf("BU %s\n", filepath::file(os::getCwd().item0))

	if par.winCross && os::getPlatform() != .posix {
		return common::error(.buildError, "Cross compile for Windows only avaiable on Linux")
	}

	meta, err := common::getMeta("box.json")
	if err.code != 0 {
		return common::error(.boxJsonError, err.msg)
	}
	
	if !meta.build.isValid {
		return common::error(.boxJsonError, "no valid build structure")
	}

	pre := meta.build.pre.get()
	if pre != "" {
		rc := std::system(pre)
		if rc != 0 {
			return common::error(.command, sprintf("pre-build exited with code %d", rc))
		}
	}

	err = par.buildTargets(meta)
	if err.code != 0 {
		return err
	}

	if par.outDir != "" {
		// copying is not needed if the output is the current directory
		for i,f in meta.build.include {
			if os::isfile(f) {
				par.addFile(f)
			} else if os::isdir(f) {
				os::walk(f, fn(p: str) |par| {
					par.addFile(p)
				})
			} else {
				return common::error(.fileNotFound, f)
			}
		}
	}

	post := meta.build.post.get()
	if post != "" {
		rc := std::system(post)
		if rc != 0 {
			return common::error(.command, sprintf("post-build exited with code %d", rc))
		}
	}

	built[os::getCwd().item0] = true

	return {}
}

fn buildDeps(par: Params, deps: []common::Dep): std::Err {
	for i,d in deps {
		meta, err := common::getMeta(filepath::join(d.srcPath, "box.json"))
		if err.code != 0 {
			return err
		}

		if err := buildDeps(par, meta.deps); err.code != 0 {
			return err
		}

		for j,cd in meta.deps {
			if !cd.buildOnly {
				continue
			}

			err := link(
				filepath::join("..", "..", "dst", cd.canonical),
				filepath::join(d.srcPath, "umbox", cd.name))
			if err.code != 0 {
				return err
			}
		}

		cwd, err := os::getCwd()
		if err.code != 0 {
			return err
		}
		
		err = os::chdir(d.srcPath)
		if err.code != 0 {
			return err
		}

		par.outDir = filepath::join("..", "..", "dst", d.canonical)
		err = build(par)
		if err.code != 0 {
			return err
		}

		err = os::chdir(cwd)
		if err.code != 0 {
			return err
		}

		for j,cd in meta.deps {
			if cd.buildOnly {
				continue
			}

			if par.link {
				err = link(
					filepath::join("..", "..", cd.canonical),
					filepath::join(d.dstPath, "umbox", cd.name))
			} else {
				err = common::copyr(cd.dstPath, filepath::join(d.dstPath, "umbox", cd.name))
			}
			if err.code != 0 {
				return err
			}
		}
	}

	return {}
}

fn run*(par: Params): std::Err {
	// Using symlinks is not allowed for external builds
	if par.outDir != "" && par.outDir != "." {
		par.link = false
	}

	meta, err := common::getMeta("box.json")
	if err.code != 0 {
		return common::error(.boxJsonError, err.msg)
	}

	err = buildDeps(par, meta.deps)
	if err.code != 0 {
		return err
	}
	
	err = build(par)
	if err.code != 0 {
		return err
	}

	for i,d in meta.deps {
		if par.link {
			err = link(
				filepath::join("dst", d.canonical),
				filepath::join("umbox", d.name))
		} else {
			err = common::copyr(
				filepath::join("umbox", "dst", d.canonical),
				filepath::join(par.outDir, "umbox", d.name))
		}
		if err.code != 0 {
			return err
		}
	}
	
	return {}
}