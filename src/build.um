
import (
	"std.um"

	"../umbox/filepath/filepath.um"
	"../umbox/os/os.um"
	"../umbox/strings/strings.um"

	"common.um"
)

type Params* = struct {
	platformTag: bool
	winCross: bool
	outDir: str
}

fn (par: ^Params) addFile(p1: str): std::Err {
	p2 := filepath::join(par.outDir, p1)
	os::mkdirp(filepath::dir(p2))
	f1, err := std::fopen(p1, "rb")
	d, err := std::freadall(f1)
	f2, err := std::fopen(p2, "wb")
	std::fwrite(f2, d)
	std::fclose(f1)
	std::fclose(f2)

	return {} // TODO
}

fn (par: ^Params) shouldRebuild(target: str, sources: []str): bool {
	target = filepath::join(par.outDir, target)

	if !os::isfile(target) {
		return true
	}
	
	tstat, err := os::stat(target)
	if err.code != 0 {
		return true
	}
	
	for i in sources {
		sstat, err := os::stat(sources[i])
		if err.code != 0 {
			return true
		}
		
		if sstat.mtime > tstat.mtime {
			return true
		}
	}
	
	return false
}

fn (par: ^Params) buildCmd(cc, ldflags, cflags, out: str, sources: []str): str {
	return sprintf("%s -shared %s -o %s %s %s",
		cc,
		ldflags,
		filepath::join(par.outDir, out),
		cflags,
		strings::join(sources, " "))
}

fn tagTarget(path: str, plat: os::Platform): str {
	suffix := ".umi"
	switch plat {
	case .posix: suffix = "_linux.umi"
	case .windows: suffix = "_windows.umi"
	case .emscripten: suffix = "_emscripten.umi"
	}

	return strings::trimsuffix(path, ".umi") + suffix
}

fn (par: ^Params) compileUMI(cc: str, path: str, target: common::Target, plat: os::Platform): std::Err {
	if par.platformTag {
		path = tagTarget(path, os::getPlatform())
	}

	rebuild := par.shouldRebuild(path, target.sources)
	if !rebuild {
		if common::debugMode { printf("No need to rebuild %s\n", path) }
		return {}
	}

	command := par.buildCmd(
		cc,
		target.ldflags.getByPlatform(plat),
		target.cflags.getByPlatform(plat),
		path,
		target.sources)
	os::mkdirp(filepath::dir(filepath::join(par.outDir, path)))
	printf("+ %s\n", command)
	rc := std::system(command)
	if rc != 0 {
		return common::error(.buildError, sprintf("build for %s exited with code %d", path, rc))
	}
	
	return {}
}

fn (par: ^Params) buildTargets(meta: common::Meta): std::Err {
	cc := std::getenv("CC")
	if cc == "" {
		cc = "cc"
	}

	for path,target in meta.build.targets {
		if filepath::ext(path) != "umi" {
			printf("Warning: Only .umi files are supported, skipping %s\n", path)
			continue
		}

		err := par.compileUMI(cc, path, target, os::getPlatform())
		if err.code != 0 {
			return err
		}

		if (par.winCross) {
			err = par.compileUMI("x86_64-w64-mingw32-gcc", path, target, .windows)
			if err.code != 0 {
				return err
			}
		}
	}

	return {}
}

fn run*(par: Params): std::Err {
	if par.winCross && os::getPlatform() != .posix {
		return common::error(.buildError, "Cross compile for Windows only avaiable on Linux")
	}

	meta, err := common::getMeta("box.json")
	if err.code != 0 {
		return common::error(.boxJsonError, err.msg)
	}
	
	if !meta.build.isValid {
		return common::error(.boxJsonError, "no valid build structure")
	}

	pre := meta.build.pre.get()
	if pre != "" {
		rc := std::system(pre)
		if rc != 0 {
			return common::error(.command, sprintf("pre-build exited with code %d", rc))
		}
	}

	err = par.buildTargets(meta)
	if err.code != 0 {
		return err
	}

	if par.outDir != "" {
		// copying is not needed if the output is the current directory
		for i,f in meta.build.include {
			if os::isfile(f) {
				par.addFile(f)
			} else if os::isdir(f) {
				os::walk(f, fn(p: str) |par| {
					par.addFile(p)
				})
			} else {
				return common::error(.fileNotFound, f)
			}
		}
	}

	post := meta.build.post.get()
	if post != "" {
		rc := std::system(post)
		if rc != 0 {
			return common::error(.command, sprintf("post-build exited with code %d", rc))
		}
	}

	return {}
}
